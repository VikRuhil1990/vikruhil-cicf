---
title: Python packages
jupyter: python3
---


Python took over the world in large part because of the thousands of packages available. A "package" is a bunch of code that does something specific, does it well, and (almost) never has to be messed with. It's wrapped up and can be treated like it's just adding something useful to the language.

The first thing you have to do is tell Python you want to use one of these packages. Let's use the "random" package to generate some random numbers:


```{python}
import random
```

Now, we can use the "random" method in the random package to generate random numbers:

```{python}
print(random.random())
print(random.random())
print(random.random())
```

That generates random numbers between zero and one. There are plenty of other functions in the random package to do things like generate random integers between two values or to randomly shuffle the items in a list.

The following part on numpy is the work of Don - I owe him a favor. :-)

"random" is an example of a built-in package. Python comes with it when it's installed. There are other packages that you would have to download to use. Let's look at an example very useful for scientific computing: numpy. Numpy is a package for making numerically-intensive programming easier and for making it run faster. It brings it's own datatype to the game: an actual array!  Numpy's arrays are quite fast - substantially faster than Python's regular way of representing arrays as "lists of lists" (or in three dimensions, "lists of lists of lists" and so forth.

First, let's tell Python we want to use numpy:

```{python}
import numpy as np
```

The "as np" part lets us specify a *namespace*, in this case a nice, short name so we don't have to type out "numpy" *every single time*.

Now we can create an array or two...

```{python}
a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
```

```{python}
z = np.zeros(3)
print(z)
```

There are convenience functions to get information about the array...

```{python}
print(a.shape)
```

```{python}
print(z.shape)
```

The "shape" property tells us how many elements there are in each dimension, and the number of values separated by commas tell use how many dimensions the array has.

(OK, I lied. Shape returns a "tuple" that describes the array and we're printing that out. A tuple is like a list.)

Let's do a little bit of linear algebra. We'll need to bring in the "linalg" part of numpy and we'll use the name "nl" as a shorthand.

```{python}
k = np.array( [ [1,1,1], [1,1,0], [1,0,0] ] )

import numpy.linalg as nl
kinv = nl.inv(k)
kinv
```

Matrix multiplication, anyone? Python has the "@" operator for exactly that:

```{python}
k @ kinv
```

For a complete list of operators, see: http://docs.python.org/library/operator.html#mapping-operators-to-functions

We've just scratched the surface of what numpy can do. Imagine how much the other thousands of Python packages can do!  The nice thing about software development, when it's done correctly, is that pieces build on top of other pieces. The "SciPy" package, for instance, has modules for integration, differentiation, linear algebra (because you can't have too much linear algebra, amiright?), signal processing, image processing (yes, a special case of signal processing)... lots of stuff.  Lots of packages then build on top of SciPy.

Hey, remember Don Stanzione talking about accelerating computing with GPUs?  I remember it like it was only last week.  Anyway, there is a mostly-complete version of NumPy and SciPy that makes your program use the GPU, at least if it's an Nvidia one. It's called CuPy. For AMD, Intel, and a few other GPUs designers, there is ClPy (that's a lower case "ell"). Just switching which packages you import and changing just a little bit you can speed your code up *by several times*.  If your code is doing a lot of linear algebra, for instance (and honestly, *who's isn't?*) then it can make a big difference.

